#!/usr/bin/env node

var hascan = require('../lib/hascan'),
    path = require('path'),
    http = require('http'),
    url = require('url'),
    fs = require('fs'),
    _ = require('underscore');

var usage = ''
  + '\n'
  + '  Usage: hascan [options] [features]\n'
  + '\n'
  + '  Options:\n'
  + '    -b, --build              builds has.js with only the tests you want\n'
  + '    -e, --eliminate          eliminate has() branches for unavailable features\n'
  + '                                 Use stdin or --file option to provide JavaScript to parse.\n'
  + '    -f, --file               path of file to read in\n'
  + '    -m, --minify             minify generated source code\n'
  + '    -s, --features           shows a json dictionary of features supported by a user agent\n'
  + '    -a, --agent              the user agent string to test\n'
  + '    -t, --tests              shows the names of all tests supportedr\n'
  + '    -u, --update             downloads the latest data from Browserscope\n'
  + '    -h, --help               output help information\n'
  ;

var browserscope =
    "http://www.browserscope.org/user/tests/table/agt1YS1wcm9maWxlcnINCxIEVGVzdBiG3-0GDA?v=3&o=json";

var args = process.argv.slice(2);
var command;
var userAgent, minify, filePath;
var features = [];
var expected;

while (args.length) {
    var arg = args.shift();
    if (expected == 'agent') {
        userAgent = arg;
        expected = null;
    } else if (expected == 'file') {
        filePath = arg;
        expected = null;
    } else {
        switch (arg) {
            case '-b':
            case '--build':
                command = function() { build(minify, features); }
                break;
            case '-e':
            case '--eliminate':
                command = function() { eliminate(filePath, minify, features); }
                break;
            case '-f':
            case '--file':
                expected = 'file';
                break;
            case '-m':
            case '--minify':
                minify = true;
                break;
            case '-s':
            case '--features':
                command = function() { listFeatures(userAgent, features); }
                break;
            case '-a':
            case '--agent':
                expected = 'agent';
                break;
            case '-t':
            case '--tests':
                command = tests;
                break;
            case '-u':
            case '--update':
                command = update;
                break;
            case '-h':
            case '--help':
                abort(usage);
                break;
            default:
                features.push(arg);
        }
    }
}

if (command) {
    command(features);
} else {
    abort(usage);
}

function build(minify, features) {
    hascan.buildHasWithTests(features, minify, function(err, js) {
        if (err) {
            console.error(err);
        } else {
            console.log(js);    
        }
    });
}

function eliminate(filePath, minify, features) {
    var source;
    if (!filePath) {
        process.stdin.resume();
        process.stdin.setEncoding('utf8');

        var chunks = [];
        process.stdin.on('data', function(chunk) {
            chunks.push(chunk);
        });
        process.stdin.on('end', function(chunk) {
            var data = chunks.join('');
            complete(data);
        });
    } else {
        fs.readFile(filePath, function(err, data) {
            if (err) {
                console.error("Unable to read " + filePath);            
            } else {
                complete(data+'');
            }
        });
    }

    function complete(data) {
        var featureMap = {};
        for (var i = 0; i < features.length; ++i) {
            featureMap[features[i]] = true;
        }
        var source = hascan.elminateFeatureTests(data, featureMap, minify, !minify);
        console.log(source);
    }
}

function listFeatures(userAgent, features) {
    hascan.getFeatureDB(features, function(err, featureDB) {
        if (err) {
            console.error("Error loading feature database: " + err)
        } else {
            var featureMap = featureDB.getFeatureMap(userAgent);
            console.log(JSON.stringify(featureMap));
        }
    });
}

function tests(features) {
    var userAgent = features.shift();

    hascan.readFeatures(function(err, hasData) {
        if (err) {
            console.error("Error loading feature database: ")
            console.error(err)
        } else {
            for (var browserId in hasData.results) {
                for (var featureId in hasData.results[browserId].results) {
                    console.log(featureId);
                }
                break;
            }
        }
    });
}

function update() {
    var URL = url.parse(browserscope);
    var options = {host: URL.host, port: URL.port, path: URL.pathname+URL.search};
    console.log('Loading', browserscope, '...');

    http.get(options, function(res) {
        var data = [];
        res.on('data', function(chunk) {
            data.push(chunk);
        });

        res.on('end', function() {
            var output = data.join('');
            var hasJsonPath = path.resolve(path.join(__dirname, '..', 'has.json'));
            var previousData;
            fs.readFile(hasJsonPath, function(err, data) {
                previousData = data ? JSON.parse(data) : null;

                var browsers = [];
                if (previousData) {
                    var newData = JSON.parse(output);
                    for (var browserId in newData.results) {
                        if (!(browserId in previousData.results)) {
                            browsers.push(browserId);
                        }
                    }
                }
                if (browsers.length) {
                    console.log(browsers.length +
                                ' new browser' + (browsers.length > 1 ? 's' : '') + ' found: ' +
                                browsers.join(', '));
                } else {
                    console.log('No new browsers found.');
                }

                fs.writeFile(hasJsonPath, output, function(err) {
                    if (err) {
                        console.error("Unable to save has.json");
                    }
                });
            });
        });
    }).on('error', function(err) {
        console.error(err);
    });
}

function abort(str) {
    console.error(str);
    process.exit(1);
}
